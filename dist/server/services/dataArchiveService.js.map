{"version":3,"file":"dataArchiveService.js","sourceRoot":"","sources":["../../../server/services/dataArchiveService.ts"],"names":[],"mappings":"AAQA,MAAM,OAAO,kBAAkB;IAG7B;QAFiB,eAAU,GAAG,YAAY,CAAC;QAGzC,OAAO,CAAC,GAAG,CAAC,yCAAyC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC;IAC1E,CAAC;IAKD,gBAAgB,CAAC,WAAmB;QAClC,OAAO,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAC3D,CAAC;IAKD,oBAAoB;QAClB,OAAO,oBAAoB,IAAI,CAAC,UAAU,GAAG,CAAC;IAChD,CAAC;IAKD,uBAAuB;QACrB,OAAO,mBAAmB,IAAI,CAAC,UAAU,GAAG,CAAC;IAC/C,CAAC;IAKD,eAAe,CAAC,YAAoB,EAAE,cAAsB;QAM1D,MAAM,QAAQ,GAAG,YAAY,GAAG,cAAc,CAAC;QAC/C,MAAM,eAAe,GAAG,CAAC,CAAC,QAAQ,GAAG,YAAY,CAAC,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QAErE,OAAO;YACL,KAAK,EAAE,YAAY;YACnB,OAAO,EAAE,cAAc;YACvB,QAAQ;YACR,eAAe,EAAE,GAAG,eAAe,yBAAyB;SAC7D,CAAC;IACJ,CAAC;IAKD,KAAK,CAAC,cAAc,CAAC,GAAQ;QAI3B,IAAI,CAAC;YACH,OAAO,CAAC,GAAG,CAAC,oDAAoD,IAAI,CAAC,UAAU,MAAM,CAAC,CAAC;YAGvF,MAAM,eAAe,GAAG,MAAM,GAAG,CAAA;;;+BAGR,IAAI,CAAC,UAAU;OACvC,CAAC;YAGF,MAAM,eAAe,GAAG,MAAM,GAAG,CAAA;;;gCAGP,IAAI,CAAC,UAAU;OACxC,CAAC;YAEF,MAAM,QAAQ,GAAG,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YACpD,MAAM,SAAS,GAAG,QAAQ,CAAC,eAAe,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;YAErD,OAAO,CAAC,GAAG,CAAC,uCAAuC,CAAC,CAAC;YACrD,OAAO,CAAC,GAAG,CAAC,sCAAsC,IAAI,CAAC,UAAU,MAAM,QAAQ,EAAE,CAAC,CAAC;YACnF,OAAO,CAAC,GAAG,CAAC,kCAAkC,IAAI,CAAC,UAAU,MAAM,SAAS,EAAE,CAAC,CAAC;YAChF,OAAO,CAAC,GAAG,CAAC,yCAAyC,CAAC,CAAC,QAAQ,GAAG,CAAC,QAAQ,GAAG,SAAS,CAAC,CAAC,GAAG,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;YAEhH,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,CAAC;QACjC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,oCAAoC,EAAE,KAAK,CAAC,CAAC;YAC3D,MAAM,KAAK,CAAC;QACd,CAAC;IACH,CAAC;CACF;AAED,MAAM,CAAC,MAAM,cAAc,GAAG,IAAI,kBAAkB,EAAE,CAAC","sourcesContent":["// Data Archive Service - Intelligente Datenarchivierung nach Datum\r\n// Optimiert Performance durch Trennung von aktuellen und historischen Daten\r\n\r\ninterface ArchiveConfig {\r\n  cutoffDate: string;\r\n  archiveOlderThan: number; // Tage\r\n}\r\n\r\nexport class DataArchiveService {\r\n  private readonly cutoffDate = '2024-06-01';\r\n  \r\n  constructor() {\r\n    console.log(`[ARCHIVE] Initialisiert mit Stichtag: ${this.cutoffDate}`);\r\n  }\r\n\r\n  /**\r\n   * Bestimmt ob Daten archiviert oder aktuell sind\r\n   */\r\n  isHistoricalData(publishedAt: string): boolean {\r\n    return new Date(publishedAt) < new Date(this.cutoffDate);\r\n  }\r\n\r\n  /**\r\n   * Erstellt Filter für aktuelle Daten (Regulatory Updates)\r\n   */\r\n  getCurrentDataFilter(): string {\r\n    return `published_at >= '${this.cutoffDate}'`;\r\n  }\r\n\r\n  /**\r\n   * Erstellt Filter für historische Daten\r\n   */\r\n  getHistoricalDataFilter(): string {\r\n    return `published_at < '${this.cutoffDate}'`;\r\n  }\r\n\r\n  /**\r\n   * Performance-Statistiken\r\n   */\r\n  getArchiveStats(totalUpdates: number, currentUpdates: number): {\r\n    total: number;\r\n    current: number;\r\n    archived: number;\r\n    performanceGain: string;\r\n  } {\r\n    const archived = totalUpdates - currentUpdates;\r\n    const performanceGain = ((archived / totalUpdates) * 100).toFixed(1);\r\n    \r\n    return {\r\n      total: totalUpdates,\r\n      current: currentUpdates,\r\n      archived,\r\n      performanceGain: `${performanceGain}% weniger Datentransfer`\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Migriert alte Daten zu historischen Daten\r\n   */\r\n  async archiveOldData(sql: any): Promise<{\r\n    archived: number;\r\n    remaining: number;\r\n  }> {\r\n    try {\r\n      console.log(`[ARCHIVE] Starte Archivierung älterer Daten (vor ${this.cutoffDate})...`);\r\n      \r\n      // Zähle Updates vor Stichtag\r\n      const oldUpdatesCount = await sql`\r\n        SELECT COUNT(*) as count \r\n        FROM regulatory_updates \r\n        WHERE published_at < ${this.cutoffDate}\r\n      `;\r\n      \r\n      // Zähle Updates nach Stichtag  \r\n      const newUpdatesCount = await sql`\r\n        SELECT COUNT(*) as count \r\n        FROM regulatory_updates \r\n        WHERE published_at >= ${this.cutoffDate}\r\n      `;\r\n      \r\n      const archived = parseInt(oldUpdatesCount[0].count);\r\n      const remaining = parseInt(newUpdatesCount[0].count);\r\n      \r\n      console.log(`[ARCHIVE] Archivierung abgeschlossen:`);\r\n      console.log(`[ARCHIVE] - Archivierte Daten (vor ${this.cutoffDate}): ${archived}`);\r\n      console.log(`[ARCHIVE] - Aktuelle Daten (ab ${this.cutoffDate}): ${remaining}`);\r\n      console.log(`[ARCHIVE] - Performance-Verbesserung: ${((archived / (archived + remaining)) * 100).toFixed(1)}%`);\r\n      \r\n      return { archived, remaining };\r\n    } catch (error) {\r\n      console.error('[ARCHIVE] Fehler bei Archivierung:', error);\r\n      throw error;\r\n    }\r\n  }\r\n}\r\n\r\nexport const archiveService = new DataArchiveService();"]}