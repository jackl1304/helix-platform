{"version":3,"file":"cachingService.js","sourceRoot":"","sources":["../../../server/services/cachingService.ts"],"names":[],"mappings":"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","sourcesContent":["import { Logger } from './logger.service';\r\n\r\nconst logger = new Logger('CachingService');\r\n\r\ninterface CacheEntry<T> {\r\n  data: T;\r\n  timestamp: number;\r\n  ttl: number;\r\n}\r\n\r\n/**\r\n * In-memory caching service for API responses and database queries\r\n * Implements TTL-based expiration and memory-efficient storage\r\n */\r\nexport class CachingService {\r\n  private static instance: CachingService;\r\n  private cache = new Map<string, CacheEntry<any>>();\r\n  private readonly maxCacheSize = 1000; // Prevent memory overflow\r\n  private cleanupInterval: NodeJS.Timeout;\r\n\r\n  private constructor() {\r\n    // Cleanup expired entries every 5 minutes\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanupExpiredEntries();\r\n    }, 5 * 60 * 1000);\r\n\r\n    logger.info('Caching service initialized', { maxCacheSize: this.maxCacheSize });\r\n  }\r\n\r\n  static getInstance(): CachingService {\r\n    if (!CachingService.instance) {\r\n      CachingService.instance = new CachingService();\r\n    }\r\n    return CachingService.instance;\r\n  }\r\n\r\n  /**\r\n   * Get cached data if valid and not expired\r\n   */\r\n  get<T>(key: string): T | null {\r\n    const entry = this.cache.get(key);\r\n    \r\n    if (!entry) {\r\n      return null;\r\n    }\r\n\r\n    const now = Date.now();\r\n    if (now - entry.timestamp > entry.ttl) {\r\n      this.cache.delete(key);\r\n      logger.debug('Cache entry expired and removed', { key });\r\n      return null;\r\n    }\r\n\r\n    logger.debug('Cache hit', { key });\r\n    return entry.data as T;\r\n  }\r\n\r\n  /**\r\n   * Set cached data with TTL in milliseconds\r\n   */\r\n  set<T>(key: string, data: T, ttlMs: number = 5 * 60 * 1000): void {\r\n    // Prevent cache from growing too large\r\n    if (this.cache.size >= this.maxCacheSize) {\r\n      this.evictOldestEntries(Math.floor(this.maxCacheSize * 0.1)); // Remove 10%\r\n    }\r\n\r\n    const entry: CacheEntry<T> = {\r\n      data,\r\n      timestamp: Date.now(),\r\n      ttl: ttlMs\r\n    };\r\n\r\n    this.cache.set(key, entry);\r\n    logger.debug('Cache entry set', { key, ttlMs, cacheSize: this.cache.size });\r\n  }\r\n\r\n  /**\r\n   * Delete specific cache entry\r\n   */\r\n  delete(key: string): boolean {\r\n    const deleted = this.cache.delete(key);\r\n    if (deleted) {\r\n      logger.debug('Cache entry deleted', { key });\r\n    }\r\n    return deleted;\r\n  }\r\n\r\n  /**\r\n   * Clear all cache entries\r\n   */\r\n  clear(): void {\r\n    const previousSize = this.cache.size;\r\n    this.cache.clear();\r\n    logger.info('Cache cleared', { previousSize });\r\n  }\r\n\r\n  /**\r\n   * Get cache statistics\r\n   */\r\n  getStats() {\r\n    return {\r\n      size: this.cache.size,\r\n      maxSize: this.maxCacheSize,\r\n      entries: Array.from(this.cache.keys())\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Cached wrapper for async functions\r\n   */\r\n  async cached<T>(\r\n    key: string, \r\n    asyncFn: () => Promise<T>, \r\n    ttlMs: number = 5 * 60 * 1000\r\n  ): Promise<T> {\r\n    // Try to get from cache first\r\n    const cached = this.get<T>(key);\r\n    if (cached !== null) {\r\n      return cached;\r\n    }\r\n\r\n    // Execute function and cache result\r\n    try {\r\n      const result = await asyncFn();\r\n      this.set(key, result, ttlMs);\r\n      return result;\r\n    } catch (error) {\r\n      logger.error('Error in cached function execution', { key, error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  private cleanupExpiredEntries(): void {\r\n    const now = Date.now();\r\n    let removedCount = 0;\r\n\r\n    for (const [key, entry] of this.cache.entries()) {\r\n      if (now - entry.timestamp > entry.ttl) {\r\n        this.cache.delete(key);\r\n        removedCount++;\r\n      }\r\n    }\r\n\r\n    if (removedCount > 0) {\r\n      logger.debug('Cleaned up expired cache entries', { \r\n        removedCount, \r\n        remainingSize: this.cache.size \r\n      });\r\n    }\r\n  }\r\n\r\n  private evictOldestEntries(count: number): void {\r\n    const entries = Array.from(this.cache.entries())\r\n      .sort((a, b) => a[1].timestamp - b[1].timestamp)\r\n      .slice(0, count);\r\n\r\n    for (const [key] of entries) {\r\n      this.cache.delete(key);\r\n    }\r\n\r\n    logger.debug('Evicted oldest cache entries', { \r\n      evictedCount: count, \r\n      remainingSize: this.cache.size \r\n    });\r\n  }\r\n\r\n  /**\r\n   * Cleanup resources\r\n   */\r\n  destroy(): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n    }\r\n    this.cache.clear();\r\n    logger.info('Caching service destroyed');\r\n  }\r\n}\r\n\r\nexport const cachingService = CachingService.getInstance();"]}